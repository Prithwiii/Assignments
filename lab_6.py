# -*- coding: utf-8 -*-
"""lab 6

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XlAiCpNWaApm8c3ZDdPdMg8o8X7OZ1Nm
"""

d#from collections import deque
N,M = map(int,input().split())
graph=[]
for j in range(N+1):
  graph.append([])
degree=[0]*(N+1)

for i in range(M):
  a,b = map(int,input().split())
  graph[a].append(b)
  degree[b]+=1

st=[]
for i in range(1,N+1):
  if degree[i]==0:
    st.append(i)
order=[]
while st:
  out= st.pop()
  order.append(out)
  for n in graph[out]:
    degree[n]-=1
    if degree[n]==0:
      st.append(n)
if len(order)==N:
  print(*order)
else:
  print(-1)

from collections import deque

N,M= map(int,input().split())
graph=[]

for i in range(N+1):
  graph.append([])
for i in range(M):
  u,v= map(int,input().split())
  graph[u].append(v)
  graph[v].append(u)
visited=[False]*(N+1)
color={}
result=0

for i in range(1,N+1):
  if not visited[i]:
    queue=deque()
    queue.append(i)
    visited[i]=True
    color[i]=0
    count=[1,0]
    while queue:
      out=queue.popleft()
      for n in graph[out]:
        if not visited[n]:
          visited[n]=True
          color[n]=1-color[out]
          count[color[n]]+=1
          queue.append(n)
    result+=max(count)
print(result)

from collections import deque
N= int(input())
a,b,u,v = map(int,input().split())
lala= [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]
visited= set()
queue=deque()
queue.append((a,b,0))
visited.add((a,b))

while queue:
  x,y,moves= queue.popleft()
  if x==u and y==v:
      print(moves)

      break
  for i,j  in lala:
    nx, ny= x+ i, y+j


    if 1<= nx<=N and 1<= ny<=N and (nx,ny) not in visited:
        visited.add((nx,ny))
        queue.append((nx,ny,moves+1))
else:
        print(-1)

import sys
from collections import deque

input = sys.stdin.read


data = input().split()
N = int(data[0])
a, b, u, v = map(int, data[1:5])


knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]

visited = [[False] * (N + 1) for _ in range(N + 1)]

queue = deque([(a, b, 0)])
visited[a][b] = True

while queue:
    x, y, moves = queue.popleft()


    if x == u and y == v:
        print(moves)
        break


    for dx, dy in knight_moves:
        nx, ny = x + dx, y + dy

        if 1 <= nx <= N and 1 <= ny <= N and not visited[nx][ny]:
            visited[nx][ny] = True
            queue.append((nx, ny, moves + 1))


else:
    print(-1)

import sys
sys.setrecursionlimit(10**6)
N,R= map(int,input().split())
graph=[]
for i in range(N+1):
  graph.append([])
for i in range(N-1):
  u,v= map(int,input().split())
  graph[u].append(v)
  graph[v].append(u)
Q= int(input())
lala=[]
for i in range(Q):
  X= int(input())
  lala.append(X)
sub= [0]*(N+1)
visited=[False]*(N+1)
def dfs(node):
  visited[node]=True
  sub[node]=1
  for n in graph[node]:
    if not visited[n]:
      dfs(n)
      sub[node]+=sub[n]
dfs(R)
for X in lala:
  print(sub[X])

import sys
sys.setrecursionlimit(10**6)
N= int(input())
a,b,u,v= map(int,input().split())
lala= [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]
min_moves= float('inf')
visited=set()
def dfs(x,y,moves):
  global min_moves
  if (x,y)==(u,v):
    min_moves= min(min_moves,moves)
    return
  if moves>=min_moves:
    return          ######### dfs for knight
  visited.add((x,y))
  for i, j in lala:
    nx,ny= x+i,y+j
    if 1<=nx<=N and 1<=ny<=N and (nx,ny) not in visited:
      dfs(nx,ny,moves+1)
  visited.remove((x,y))
dfs(a,b,0)
if min_moves==float('inf'):
  print(-1)
else:
  print(min_moves)

N= int(input())
graph=[]
for i in range(N+1):
  graph.append([])
for i in range(N-1):
  u,v=map(int,input().split())
  graph[u].append(v)
  graph[v].append(u)
def bfs(start):
  visited=[-1]*(N+1)
  visited[start]= 0
  st= [start]
  far_node=start
  while st:
    node= st.pop()
    for n in graph[node]:
      if visited[n]==-1:
        visited[n]=visited[node]+1
        st.append(n)
        if visited[n]>visited[far_node]:
          far_node=n
  return far_node,visited[far_node]
far_from_start,_= bfs(1)
far_node,max_dist=bfs(far_from_start)
print(max_dist)
print(far_from_start,far_node)

from collections import deque
N= int(input())
s=[]
for i in range(N):
  s.append(str(input()))
graph={}
in_degree={}

for word in s:
  for char in word:
    if char not in in_degree:
      in_degree[char]=0
    if char not in graph:
      graph[char]= set()
for i in range(N-1):
  word1,word2 = s[i], s[i+1]
  min_len= min(len(word1),len(word2))
  found_diff= False
  for j in range(min_len):
    if word1[j]!= word2[j]:
      if word2[j] not in graph[word1[j]]:
        graph[word1[j]].add(word2[j])
        in_degree[word2[j]]+=1
      found_diff= True
      break
  if not found_diff and len(word1)> len(word2):
    print(-1)
    exit()
queue= deque()
for char in in_degree:
  if in_degree[char]==0:
    queue.append(char)
result=[]
while queue:
  char=min(queue)
  result.append(char)
  queue.remove(char)

  for n in graph[char]:
     in_degree[n]-=1
     if in_degree[n]==0:
      queue.append(n)
if len(result)!= len(in_degree):
  print(-1)
else:
  print(''.join(result))

from collections import deque

board_size = int(input())
start_x, start_y, end_x, end_y = map(int, input().split())

knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1),
                (1, 2), (-1, 2), (1, -2), (-1, -2)]

visited = [[0] * (boardsize + 1) for  in range(board_size + 1)]
steps = [[0] * (boardsize + 1) for  in range(board_size + 1)]

queue = deque()
queue.append((start_x, start_y))
visited[start_x][start_y] = 1

while queue:
    curr_x, curr_y = queue.popleft()

    if (curr_x, curr_y) == (end_x, end_y):
        print(steps[curr_x][curr_y])
        break

    for dx, dy in knight_moves:
        next_x, next_y = curr_x + dx, curr_y + dy

        if 0 < next_x <= board_size and 0 < next_y <= board_size:
            if visited[next_x][next_y] == 0:
                visited[next_x][next_y] = 1
                steps[next_x][next_y] = steps[curr_x][curr_y] + 1
                queue.append((next_x, next_y))
else:
    print(-1)