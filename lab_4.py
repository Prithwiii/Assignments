# -*- coding: utf-8 -*-
"""lab 4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hsdF1z4XgIoPBwdKpUaHqOalQOoxilgD
"""

from collections import deque
N,M= map(int,input().split())
graph=[]
for k in range(N+1):
  graph.append([])
for i in range(M):
   u,v=map(int,input().split())
   graph[u].append(v)
   graph[v].append(u)
for j in range:
  graph[j].sort()
def bfs(yo):
  visit= [False]*(N+1)
  queue= deque([yo])
  visit[yo]=True
  order=[]
  while queue:
    out= queue.popleft()
    order.append(out)
    for i in graph[out]:
      if not visit[i]:
        visit[i]=True
        queue.append(i)
  return order
result= bfs(1)
print(' '.join(map(str,result)))

N,M= map(int,input().split())
sec= list(map(int,input().split()))
thrd= list(map(int,input().split()))
graph=[]
for i in range(N+1):
  graph.append([])
for i in range(M):
  graph[sec[i]].append(thrd[i])
  graph[thrd[i]].append(sec[i])
for p in range(N+1):
  graph[p].sort()
def dfs(yo):
  stack=[yo]
  visit= [False]*(N+1)
  order=[]


  while stack:
    out= stack.pop()
    if not visit[out]:
     visit[out]=True
     order.append(out)
     for n in reversed(graph[out]):
        if not visit[n]:
          stack.append(n)
  return order
result= dfs(1)
print(' '.join(map(str, result)))

from collections import deque
N,M,S,D= map(int,input().split())
sec= list(map(int,input().split()))
thrd= list(map(int,input().split()))
graph=[]
for i in range(N+1):
  graph.append([])
for i in range(M):
  graph[sec[i]].append(thrd[i])
  graph[thrd[i]].append(sec[i])
for p in range(N+1):
  graph[p].sort()
def shortest(S,D):
  queue=deque([S])
  visit=[False]*(N+1)
  visit[S]=True
  main= [-1]*(N+1)
  while queue:
    out= queue.popleft()
    if out==D:
      break
    for n in graph[out]:
      if not visit[n]:
        visit[n]=True
        main[n]=out
        queue.append(n)
  if not visit[D]:
    print(-1)
    return
  result=[]
  curr=D
  while curr!=-1:
    result.append(curr)
    curr=main[curr]
  result.reverse()
  print(len(result)-1)
  print(' '.join(map(str, result)))
shortest(S,D)

from collections import deque
N,M,S,D,K= list(map(int,input().split()))


graph=[]
for i in range(N+1):
  graph.append([])
for i in range(M) :
  u,v= map(int,input().split())
  graph[u].append(v)


def path(a,b):
  queue=deque([a])
  visit=[False]*(N+1)
  visit[a]=True
  main= [-1]*(N+1)
  while queue:
    out= queue.popleft()
    if out==b:
      break
    for n in graph[out]:
      if not visit[n]:
        visit[n]=True
        main[n]=out
        queue.append(n)
  if not visit[b]:

    return
  result=[]
  curr=b
  while curr!=-1:
    result.append(curr)
    curr=main[curr]
  return result[::-1]
path1= path(S,K)
path2=path(K,D)
if path1 is None or path2 is None:
  print(-1)
else:
  full= path1+path2[1:]
  print(len(full)-1)
  print(' '.join(map(str, full)))

import sys

sys.setrecursionlimit(2*100000+5)
N,M = map(int,input().split())
graph=[]
for i in range(N+1):
  graph.append([])
for i in range(M):
  u,v= map(int,input().split())
  graph[u].append(v)
visit= [False]*(N+1)
again= [False]*(N+1)
def cycle(yo):

   visit[yo]=True
   again[yo]=True
   for n in graph[yo]:
    if not visit[n]:
      if cycle(n):
        return True
    elif again[n]:
      return True
   again[yo]=False
   return False


flag=False
for i in range(1,N+1):
  if not visit[i]:
    if cycle(i):
      flag=True
      break
if flag:
  print("YES")
else:
  print("NO")

N, M = map(int, input().split())
graph = [[] for _ in range(N + 1)]

for _ in range(M):
    u, v = map(int, input().split())
    graph[u].append(v)

status = [0] * (N + 1)  # 0: unvisited, 1: visiting, 2: visited

def has_cycle_iterative(start):
    stack = []
    path = []

    stack.append((start, 0))  # (current_node, index of next neighbor to explore)

    while stack:
        node, i = stack[-1]

        if status[node] == 0:
            status[node] = 1  # mark as visiting
            path.append(node)

        neighbors = graph[node]

        if i < len(neighbors):
            neighbor = neighbors[i]
            stack[-1] = (node, i + 1)  # move to next neighbor

            if status[neighbor] == 0:
                stack.append((neighbor, 0))
            elif status[neighbor] == 1:
                return True  # cycle detected
        else:
            status[node] = 2
            stack.pop()
            path.pop()

    return False

for i in range(1, N + 1):
    if status[i] == 0:
        if has_cycle_iterative(i):
            print("YES")
            break
else:
    print("NO")

R,H= map(int,input().split())
main=[]
for i in range(R):

    row=list(input().strip())
    main.append(row)
x=[-1,1,0,0]
y=[0,0,-1,1]
visit= [[False for i in range(H)] for j in range(R)]
diamond=0
for i in range(R):
  for j in range(H):
    if not visit[i][j] and main [i][j] != "#" :
       hehe =[(i,j)]
       visit[i][j]= True
       if main[i][j]=="D":
        count=1
       else:
        count=0
       idx=0
       while idx< len(hehe):
         a,b = hehe[idx]
         idx+=1
         for k in range(4):
          newx= a+x[k]
          newy= b+ y[k]
          if 0<= newx <R and 0<=newy <H:
            if not visit[newx][newy] and main[newx][newy]!="#":
               visit[newx][newy]= True
               hehe.append((newx,newy))
               if main[newx][newy]=="D":
                count+=1
       diamond= max(diamond,count)
print(diamond)

from collections import deque

def has_odd_length_cycle(graph, n):
    color = [-1] * n  # -1 means unvisited

    for start in range(n):
        if color[start] == -1:
            queue = deque()
            queue.append(start)
            color[start] = 0  # Start with color 0

            while queue:
                node = queue.popleft()

                for neighbor in graph[node]:
                    if color[neighbor] == -1:
                        color[neighbor] = 1 - color[node]
                        queue.append(neighbor)
                    elif color[neighbor] == color[node]:
                        # Found two adjacent nodes with the same color
                        print(f"Odd-length cycle detected between node {node} and {neighbor}")
                        return True
    return False

from collections import deque

def is_bipartite(graph):
    color = {}
    for node in graph:
        if node not in color:
            queue = deque([node])
            color[node] = 0             #####A graph is bipartite if
                                         #its vertices can be divided
                                         #into two disjoint sets such that
                                         #every edge connects a vertex in one set to
                                         #a vertex in
                                         #the other set â€” and no edge
                                         #connects vertices within the same set.
            while queue:
                u = queue.popleft()
                for v in graph[u]:
                    if v not in color:
                        color[v] = 1 - color[u]
                        queue.append(v)
                    elif color[v] == color[u]:
                        return False
    return True

from collections import deque

# Define the city connections
city_graph = {
    'Rome': ['Milan', 'Venice', 'Florence'],
    'Milan': ['Rome', 'Florence', 'Bologna', 'Venice'],
    'Florence': ['Milan', 'Naples', 'Rome', 'Bologna', 'Venice'],
    'Venice': ['Rome', 'Milan', 'Florence'],
    'Naples': ['Florence', 'Bologna', 'Genoa'],
    'Turin': ['Genoa'],
    'Bologna': ['Naples', 'Genoa', 'Milan', 'Florence'],
    'Genoa': ['Turin', 'Bologna', 'Naples'],
    'Palermo': ['Catania', 'Syracuse'],
    'Catania': ['Palermo', 'Syracuse'],
    'Syracuse': ['Catania', 'Palermo']
}

# Sort neighbors alphabetically to pick smallest first
for city in city_graph:
    city_graph[city].sort()

def bfs_with_time(start):
    visited = {city: False for city in city_graph}
    time_to_infect = {city: -1 for city in city_graph}
    queue = deque()

    visited[start] = True
    time_to_infect[start] = 0
    queue.append((start, 0))

    while queue:
        current_city, current_time = queue.popleft()

        for neighbor in city_graph[current_city]:
            if not visited[neighbor]:
                visited[neighbor] = True
                time_to_infect[neighbor] = current_time + 1
                queue.append((neighbor, current_time + 1))

    return time_to_infect

# Run the BFS simulation
infection_result = bfs_with_time("Rome")

# Print results sorted alphabetically
print("\nInfection Time by City:")
for city in sorted(infection_result):
    print(f"{city}: {infection_result[city]}")

N, M = map(int, input().split())
sec = list(map(int, input().split()))
thrd = list(map(int, input().split()))

# Create a directed graph
graph = [[] for _ in range(N + 1)]
for i in range(M):
    graph[sec[i]].append(thrd[i])  # Directed edge from sec[i] to thrd[i]

for p in range(N + 1):
    graph[p].sort()  # Optional, to get lexicographically smaller results

visited = [False] * (N + 1)
result = []

def dfs(node):
    visited[node] = True
    for neighbor in graph[node]:
        if not visited[neighbor]:
            dfs(neighbor)
    result.append(node)  # Post-order add

# Run DFS from all nodes (in case the graph is disconnected)
for i in range(1, N + 1):
    if not visited[i]:
        dfs(i)

########## Reverse for topological order
result.reverse()
print(' '.join(map(str, result)))