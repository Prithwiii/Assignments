# -*- coding: utf-8 -*-
"""lab assignment 7

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wYX6SzEFAsr0FDbaW3sZFcrRx5zXz2H0
"""

import heapq

N,M,S,D = map(int,input().split())
first= list(map(int,input().split()))
scnd= list(map(int,input().split()))
thrd= list(map(int,input().split()))
graph=[]
for i in range(N+1):
  graph.append([])
for i in range(M):
  graph[first[i]].append((scnd[i],thrd[i]))
rndm= [float('inf')]*(N+1)
parent=[-1]*(N+1)
rndm[S]=0
heap=[(0,S)]
while heap:
  d,node= heapq.heappop(heap)
  if d> rndm[node]:
    continue
  for n,w in graph[node]:
       if rndm[n]> rndm[node]+w:
          rndm[n]=rndm[node]+w
          parent[n]=node
          heapq.heappush(heap,(rndm[n],n))
if rndm[D]==float('inf'):
  print(-1)
else:
  print(rndm[D])
  path=[]
  current=D
  while current!=-1:
    path.append(current)
    current= parent[current]
  print(' '.join(map(str,reversed(path))))

import heapq
N,M,S,T= map(int,input().split())
graph=[]
for i in range(N+1):
  graph.append([])
for i in range(M):
  u,v,w= map(int,input().split())
  graph[u].append((v,w))
def dijkstra(s,g,N):
  dist= [float('inf')]*(N+1)
  dist[s]=0
  heap= [(0,s)]
  while heap:
    d,node= heapq.heappop(heap)
    if d> dist[node]:
      continue
    for n,w in graph[node]:
      if dist[n]>d+w:
        dist[n]=d+w
        heapq.heappush(heap, (dist[n],n))
  return dist
alice= dijkstra(S,graph,N)
bob=dijkstra(T,graph,N)
min_time= float('inf')
meeting_node=-1
for i in range(1,N+1):
  if alice[i]< float('inf') and bob[i]< float('inf'):
    meet_time=max(alice[i],bob[i])
    if meet_time<min_time or (meet_time==min_time and i < meeting_node):
       min_time=meet_time
       meeting_node=i
if meeting_node==-1:
  print(-1)
else:
  print(min_time,meeting_node)

import heapq
N,M= map(int,input().split())
graph=[]
for i in range(N+1):
  graph.append([])

for i in range(M):
  u,v,w= map(int,input().split())
  graph[u].append((v,w))
  graph[v].append((u,w))
d= [float('inf')]*(N+1)
d[1]=0
heap=[(0,1)]
while heap:
  max_d,node=heapq.heappop(heap)
  if max_d>d[node]:
    continue
  for n,w in graph[node]:
    new_d= max(max_d,w)
    if new_d<d[n]:
      d[n]=new_d
      heapq.heappush(heap,(new_d,n))
for i in range(1,N+1):
  if d[i]==float('inf'):
    print(-1)
  else:
    print(d[i],end=" ")

import heapq
N,M,S,D= map(int,input().split())
w= list(map(int,input().split()))
graph=[]
for _ in range(N+1):
  graph.append([])
for i in range(M):
  u,v= map(int,input().split())
  graph[u].append(v)

cost= [float('inf')]*(N+1)
cost[S]= w[S-1]
heap= [(cost[S],S)]
while heap:
  c,node= heapq.heappop(heap)
  if c>cost[node]:
    continue
  for n in graph[node]:
     new_cost=c+w[n-1]
     if new_cost<cost[n]:
      cost[n]=new_cost
      heapq.heappush(heap,(new_cost,n))

if cost[D]!=float('inf'):
  print(cost[D])
else:
  print(-1)

import heapq
N,M =map(int,input().split())
u= list(map(int,input().split()))
v=list(map(int,input().split()))
w=list(map(int,input().split()))
graph=[]
for _ in range(N+1):
  graph.append([])
for i in range(M):
  graph[u[i]].append((v[i],w[i]))
dist=[]
for _ in range(N+1):
  dist.append([float('inf'), float('inf')])
dist[1][0]=0
heap=[(0,1,-1)]
while heap:
  c,node,l=heapq.heappop(heap)
  for n,w in graph[node]:
     curr= w%2
     if l==-1 or curr!=l:
       if c +w< dist[n][curr]:
        dist[n][curr]= c+w
        heapq.heappush(heap,(c+w,n,curr))

res= min(dist[N])
if res!=float('inf'):
  print(res)
else:
  print(-1)

import heapq
N,M,S,D= map(int,input().split())
graph=[]
for _ in range(N+1):
  graph.append([])
for i in range(M):
  u,v,w= map(int,input().split())
  graph[u].append((v,w))
  graph[v].append((u,w))
dist=[]
for _ in range(N+1):
  dist.append([float('inf'), float('inf')])
dist[S][0]=0
heap=[(0,S)]
while heap:
  cost,node= heapq.heappop(heap)
  for n,w in graph[node]:
    new_cost= cost+w
    if new_cost< dist[n][0]:
      dist[n][1]=dist[n][0]
      dist[n][0]=new_cost
      heapq.heappush(heap,(new_cost,n))
    elif dist[n][0]< new_cost<dist[n][1]:
      dist[n][1]=new_cost
      heapq.heappush(heap,(new_cost,n))
if dist[D][1]!=float('inf'):
  print(dist[D][1])
else:
  print(-1)