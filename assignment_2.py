# -*- coding: utf-8 -*-
"""Assignment 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kfH0_hhyUP_wEOLP0mwXKAKSFOQH9AQG
"""

N= int(input())
points=[]
for i in range(N):

   co1, co2= map(int,input().split())
   points.append((co1,co2,i+1))
points.sort()
def distance(p1,p2):
  return ((p2[0]-p1[0])**2 + (p2[1]-p1[1])**2)**0.5
def bruteForce(a):
   n=len(a)
   d= float('inf')
   pair= (None,None)
   for i in range(n):
    for j in range(i+1,n):
      dist=distance(a[i],a[j])
      if dist<d:
        d=dist
        pair=(a[i],a[j])
   return pair[0],pair[1],d
def pairs(sorted_list):
  n= len(sorted_list)
  if n<=3:
    return bruteForce(sorted_list)

  mid= n//2
  mid_x= sorted_list[mid][0]
  left= sorted_list[:mid]

  right= sorted_list[mid:]
  co1_left,co2_left,dist_left= pairs(left)
  co1_right,co2_right,dist_right= pairs(right)
  if dist_left<dist_right:
    pair= (co1_left,co2_left)
    d= dist_left
  else:
     pair= (co1_right,co2_right)
     d= dist_right
  strip=[]


  for point in sorted_list:
    if abs(point[0]-mid_x)<d:
      strip.append(point)
  strip.sort(key=lambda point:point[1])
  for i in range(len(strip)):
    for j in range(i+1, min(i+8,len(strip))):
      m= distance(strip[i], strip[j])
      if m<d:
        d=m
        pair=(strip[i],strip[j])
  return pair[0], pair[1], d
p1,p2,d=pairs(points)
id1,id2= sorted([p1[2],p2[2]])
print(f"{id1} {id2} {d:.6f}")

N,M = map(int,input().split())
graph=[]
for i in range(N):
  row=[]
  for j in range(N):
     row.append(0)
  graph.append(row)
for k in range(M):
  p,q,r= map(int,input().split())
  graph[p-1][q-1]=r
for row in graph:
   print(' '.join(map(str,row)))

N,M = map(int,input().split())

list1= []
for i in range(N+1):
  list1.append([])
sec= list(map(int,input().split()))
thrd=list(map(int,input().split()))
frth=list(map(int,input().split()))
for i in range(M):
  list1[sec[i]].append((thrd[i],frth[i]))


for k in range(1,N+1):
  print(f"{k}:",end=" ")
  edg=list1[k]
  if edg:
    for i in range(len(list1[k])):
      a= list1[k][i]
      print(a, end=" ")
    print()
  else:
    print()

N= int(input())
matrix= []
for i in range(N):
  row=[]
  for j in range(N):
    row.append(0)
  matrix.append(row)
for i in range(N):
  nodes= list(map(int,input().split()))
  nodes2= nodes[1:]
  for k in nodes2:

    matrix[i][k]=1

for row in matrix:
   print(' '.join(map(str,row)))

N,M= map(int,input().split())
sec= list(map(int,input().split()))
thrd= list(map(int,input().split()))

odd_degree=0
count= [0]*(N+1)
for i in range(M):
  count[sec[i]]+=1
  count[thrd[i]]+=1
for i in range(1,N+1):
  if count[i]%2!=0:
    odd_degree+=1
if odd_degree>2:
  print("NO")
else:
  print("YES")

N,M= map(int,input().split())
sec= list(map(int,input().split()))
thrd= list(map(int,input().split()))
in_degrees=[0]*(N+1)
out_degrees= [0]*(N+1)
final=[0]*(N+1)
for i in range(M):
  out_degrees[sec[i]]+=1
  in_degrees[thrd[i]]+=1
for k in range(len(in_degrees)):
  final[k]=in_degrees[k]-out_degrees[k]
print(' '.join(map(str,final[1:])))

N= int(input())
pos1,pos2= map(int,input().split())

list1=[]
for i in range(-1,2):
  for j in range(-1,2):
   if i==0 and j==0:
     continue
   new_pos1= pos1+i
   new_pos2=pos2+j
   if 1<=new_pos1<=N and 1<=new_pos2<=N:
    list1.append((new_pos1,new_pos2))
list1.sort()
print(len(list1))
for j in list1:
  print(j[0], j[1])

N,Q= map(int,input().split())
ne=[]
list1=[]
for i in range(Q):
  X,K= map(int,input().split())
  list1.append((X,K))
def gcd(a,b):
  while b!=0:
    a,b=b,a%b
  return a
for i in range(N+1):
  ne.append([])
for i in range(1,N+1):
  for j in range(1,N+1):
    if i!=j and gcd(i,j)==1:
       ne[i].append(j)
for k in range(1,N+1):
  ne[k].sort()
for x,k in list1:
  if k<=len(ne[x]):
    print(ne[x][k-1])
  else:
    print(-1)